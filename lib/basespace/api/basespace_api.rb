# Copyright 2013 Toshiaki Katayama, Joachim Baran
#
#     Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# 
#     Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

require 'basespace/api/api_client'
require 'basespace/api/base_api'
require 'basespace/api/basespace_error'
require 'basespace/model/query_parameters'

require 'net/https'
require 'uri'
require 'json'

Net::HTTP.version_1_2

module Bio
  module BaseSpace

    # The main API class used for all communication with the BaseSpace REST server.
    class BaseSpaceAPI < BaseAPI

      # URIs for obtaining a access token, user verification code, and app trigger information.
      TOKEN_URL      = '/oauthv2/token'
      DEVICE_URL     = "/oauthv2/deviceauthorization"
      WEB_AUTHORIZE  = '/oauth/authorize'

      attr_reader :app_session_id

      # Load credentials and start a new BaseSpace session.
      def self.start
        if opts = Bio::BaseSpace.load_credentials
          self.new(opts)
        else
          raise "Please specify your BaseSpace credentials in the credentials.json file or use Bio::BaseSpace::BaseSpaceAPI.new with arguments"
        end
      end

      # Create a new object for communicating with the BaseSpace REST server; preferred method of calling
      # is through the 'start' class method.
      #
      # +client_key+:: Client key to use for authentication (provided when registering an App).
      # +client_secret+:: Client secret key to use for authentication (provided when registering an App).
      # +api_server+:: URI of the BaseSpace API server.
      # +version+:: API version to use.
      # +app_session_id+:: App session ID that was generated by application triggering.
      # +access_token+:: Access token provided by App triggering.
      def initialize(params = {})
        end_with_slash = %r(/$)
        unless params['basespace_url'][end_with_slash]
          params['basespace_url'] += '/'
        end
        
        @app_session_id  = params['app_session_id']
        @key             = params['client_id']
        @secret          = params['client_secret']
        @version         = params['api_version']
        @api_server      = params['basespace_url'] + @version
        @weburl          = params['basespace_url'].sub('api.', '')
        @timeout         = nil

        super(params['access_token'])
      end

      # This method is not for general use and should only be called from 'get_app_session'.
      #
      # +obj+:: Application trigger JSON.
      def get_trigger_object(obj)
        if obj['ResponseStatus'].has_key?('ErrorCode')
          raise 'BaseSpace error: ' + obj['ResponseStatus']['ErrorCode'].to_s + ": " + obj['ResponseStatus']['Message']
        end
        #access_token = nil  # '' is false in Python but APIClient.new only raises when the value is None (not '')
        access_token = ''
        temp_api = APIClient.new(access_token, @api_server)
        response = temp_api.deserialize(obj, 'AppSessionResponse')
        # AppSessionResponse object has a response method which returns a AppSession object
        app_sess = response.get_attr('Response')
        # AppSession object has a serialize_references method which converts an array of
        # AppSessionLaunchObject objects by calling serialize_object method in each object.
        # The method in turn calls the serialize_object method of the given BaseSpaceAPI object
        # with @content ('dict') and @type ('str') arguments. Returns an array of serialized objects.
        res = app_sess.serialize_references(self)
      end
      
      def serialize_object(d, type)
        # [TODO] None (nil) or '' ?
        #access_token = nil
        access_token = ''
        temp_api = APIClient.new(access_token, @api_server)
        case type.downcase
        when 'project'
          return temp_api.deserialize(d, 'Project')
        when 'sample'
          return temp_api.deserialize(d, 'Sample')
        when 'appresult'
          return temp_api.deserialize(d, 'AppResult')
        else
          return d
        end
      end


      # Returns the AppSession instance identified by the given ID.
      #
      # +id+:: The ID of the AppSession.
      def get_app_session_by_id(id)
        # TO_DO make special case for access-token only retrieval
        get_app_session(id)
      end

      # Returns an AppSession instance containing user and data-type the app was triggered by/on.
      #
      # +id+:: The AppSessionId, ID not supplied the AppSessionId used for instantiating the BaseSpaceAPI instance.
      def get_app_session(id = nil)
        if (not @app_session_id) and (not id)
          raise "This BaseSpaceAPI instance has no app_session_id set and no alternative id was supplied for method get_app_session"
        end

        # if (not id) and (not @key)
        #   raise "This BaseSpaceAPI instance has no client_secret (key) set and no alternative id was supplied for method get_app_session"
        # end

        resource_path = @api_server + "/appsessions/#{id || @app_session_id}"

        if $DEBUG
          $stderr.puts "    # ----- BaseSpaceAPI#get_app_session ----- "
          $stderr.puts "    # resource_path: #{resource_path}"
          $stderr.puts "    # "
        end
        uri = URI.parse(resource_path)
        uri.user = @key
        uri.password = @secret
        #response = Net::HTTP.get(uri)
        http_opts = {}
        http_opts[:use_ssl] = true if uri.scheme == "https"
        response = Net::HTTP.start(uri.host, uri.port, http_opts) do |http|
          case RUBY_VERSION
          when /^1.9/
            if uri.query and not uri.query.empty?
              request = Net::HTTP::Get.new(uri.path + '?' + uri.query)
            else
              request = Net::HTTP::Get.new(uri.path)
            end
          else
            request = Net::HTTP::Get.new(uri)
          end
          request.basic_auth uri.user, uri.password
          http.request(request)
        end
        obj = JSON.parse(response.body)
        # TODO add exception if response isn't OK, e.g. incorrect server gives path not recognized
        get_trigger_object(obj)
      end

      # Request access to a data object.
      #
      # +obj+:: The data object we wish to get access to.
      # +access_type+:: The type of access (read|write), default is write.
      # +web+:: If the App is web-based, then set this parameter to 'true'. The default value is false, which means that the request is for a device based App.
      # +redirect_url+:: For the web-based case, a redirection URL.
      # +state+:: (unclear from Python port)
      def get_access(obj, access_type = 'write', web = nil, redirect_url = nil, state = nil)
        scope_str = obj.get_access_str(access_type)
        web ? get_web_verification_code(scope_str, redirect_url, state) : get_verification_code(scope_str)
      end
          
      # Returns the BaseSpace dictionary containing the verification code and verification URL for the user to approve
      # access to a specific data scope.  
      # 
      # Corresponding curl call:
      # curlCall = 'curl -d "response_type=device_code" -d "client_id=' + client_key + '" -d "scope=' + scope + '" ' + DEVICE_URL
      # 
      # For details see:
      # https://developer.basespace.illumina.com/docs/content/documentation/authentication/obtaining-access-tokens
      # 
      # +scope+:: The scope that access is requested for.
      def get_verification_code(scope)
        #curlCall = 'curl -d "response_type=device_code" -d "client_id=' + @key + '" -d "scope=' + scope + '" ' + @api_server + DEVICE_URL
        #puts curlCall
        unless @key
          raise "This BaseSpaceAPI instance has no client_secret (key) set and no alternative id was supplied for method get_verification_code."
        end
        data = {'client_id' => @key, 'scope' => scope, 'response_type' => 'device_code'}
        make_curl_request(data, @api_server + DEVICE_URL)
      end

      # Generates the URL the user should be redirected to for web-based authentication.
      #  
      # +scope+: The scope that access is requested for.
      # +redirect_url+:: The redirect URL.
      # +state+:: An optional state parameter that will passed through to the redirect response.
      def get_web_verification_code(scope, redirect_url, state = nil)
        if (not @key)
          raise "This BaseSpaceAPI instance has no client_id (key) set and no alternative id was supplied for method get_verification_code."
        end
        data = {'client_id' => @key, 'redirect_uri' => redirect_url, 'scope' => scope, 'response_type' => 'code', "state" => state}
        @weburl + WEB_AUTHORIZE + '?' + URI.encode_www_form(data)
      end

      # Returns a user specific access token.    
      #
      # +device_code+:: The device code returned by the verification code method.
      def obtain_access_token(device_code)
        if !@key || !@secret
          raise "This BaseSpaceAPI instance has either no client_secret or no client_id set and no alternative id was supplied for method get_verification_code."
        end
        data = {'client_id' => @key, 'client_secret' => @secret, 'code' => device_code, 'grant_type' => 'device', 'redirect_uri' => 'google.com'}
        dict = make_curl_request(data, @api_server + TOKEN_URL)
        dict['access_token']
      end

      def update_privileges(code)
        token = obtain_access_token(code)
        set_access_token(token)
      end

      # Creates a project with the specified name and returns a project object. 
      # If a project with this name already exists, the existing project is returned.
      #
      # +name+:: Name of the project.
      def create_project(name)
        #: v1pre3/projects, it requires 1 input parameter which is Name
        single_request('ProjectResponse', '/projects/', 'POST', {}, {}, { 'Name' => name })
      end
              
      # Returns the User object corresponding to ID.
      #
      # +id+:: The ID of the user.
      def get_user_by_id(id)
        single_request('UserResponse', "/users/#{id}", 'GET')
      end
             
      # Returns an AppResult object corresponding to ID.
      #
      # +param id+:: The ID of the AppResult.
      def get_app_result_by_id(id)
        single_request('AppResultResponse', "/appresults/#{id}", 'GET')
      end

      # Returns a list of File objects for the AppResult with the given ID.
      # 
      # +id+:: The ID of the AppResult.
      # +qp: An object of type QueryParameters for custom sorting and filtering.
      def get_app_result_files(id, qp = {})
        query_pars = qp.kind_of?(Hash) ? QueryParameters.new(qp) : qp
        query_pars.validate
        query_params = query_pars.get_parameter_dict
        list_request('File', "/appresults/#{id}/files", 'GET', query_params)
      end

      # Request a project object by ID.
      # 
      # +id+:: The ID of the project.
      def get_project_by_id(id)
        single_request('ProjectResponse', "/projects/#{id}", 'GET')
      end
             
      # Returns a list available projects for a User with the specified ID.
      # 
      # +id+:: The ID of the user.
      # +qp+:: An object of type QueryParameters for custom sorting and filtering.
      def get_project_by_user(id, qp = {})
        query_pars = qp.kind_of?(Hash) ? QueryParameters.new(qp) : qp
        query_pars.validate
        query_params = query_pars.get_parameter_dict
        list_request('Project', "/users/#{id}/projects", 'GET', query_params)
      end
         
      # Returns a list of accessible runs for the User with the given ID.
      # 
      # +id+:: User id.
      # +qp+:: An object of type QueryParameters for custom sorting and filtering.
      def get_accessible_runs_by_user(id, qp = {})
        query_pars = qp.kind_of?(Hash) ? QueryParameters.new(qp) : qp
        query_pars.validate
        query_params = query_pars.get_parameter_dict
        list_request('RunCompact', "/users/#{id}/runs", 'GET', query_params)
      end
      
      # Returns a list of AppResult object associated with the project with ID.
      # 
      # +id+:: The project ID.
      # +qp+:: An object of type QueryParameters for custom sorting and filtering.
      # +statuses+:: A list of AppResult statuses to filter by.
      def get_app_results_by_project(id, qp = {}, statuses = [])
        query_pars = qp.kind_of?(Hash) ? QueryParameters.new(qp) : qp
        query_pars.validate
        query_params = query_pars.get_parameter_dict
        query_params['Statuses'] = statuses.join(",") unless statuses.empty?
        list_request('AppResult', "/projects/#{id}/appresults", 'GET', query_params)
      end

      # Returns a list of samples associated with a project with ID.
      # 
      # +id+:: The ID of the project.
      # +qp+:: An object of type QueryParameters for custom sorting and filtering.
      def get_samples_by_project(id, qp = {})
        query_pars = qp.kind_of?(Hash) ? QueryParameters.new(qp) : qp
        query_pars.validate
        query_params = query_pars.get_parameter_dict
        list_request('Sample', "/projects/#{id}/samples", 'GET', query_params)
      end

      # Returns a Sample object.
      # 
      # +id+:: The ID of the sample.
      def get_sample_by_id(id)
        single_request('SampleResponse', "/samples/#{id}", 'GET')
      end

      # Returns a list of File objects associated with sample with ID.
      # 
      # +id+:: Sample ID.
      # +qp+:: An object of type QueryParameters for custom sorting and filtering.
      def get_files_by_sample(id, qp = {})
        query_pars     = qp.kind_of?(Hash) ? QueryParameters.new(qp) : qp
        query_pars.validate
        query_params   = query_pars.get_parameter_dict
        list_request('File', "/samples/#{id}/files", 'GET', query_params)
      end
      
      # Returns a file object by ID.
      # 
      # +id+:: The ID of the file.
      def get_file_by_id(id)
        single_request('FileResponse', "/files/#{id}", 'GET')
      end

      # Returns an instance of Genome with the specified ID.
      # 
      # +id+:: The genome ID.
      def get_genome_by_id(id)
        single_request('GenomeResponse', "/genomes/#{id}", 'GET')
      end

      # Returns a list of all available genomes.
      # 
      # +qp+:: An object of type QueryParameters for custom sorting and filtering.
      def get_available_genomes(qp = {})
        query_pars = qp.kind_of?(Hash) ? QueryParameters.new(qp) : qp
        query_pars.validate
        query_params = query_pars.get_parameter_dict
        list_request('GenomeV1', '/genomes', 'GET', query_params)
      end
      
      # TODO, needs more work in parsing meta data, currently only map keys are returned.
      
      # Returns a VariantMetadata object for a variant file.
      # 
      # +id+:: ID of the VCF file.
      # +format+:: Set to 'vcf' to get the results as lines in VCF format.
      def get_variant_metadata(id, format)
        query_params = { 'Format' => to_path_value(format) }
        single_request('VariantsHeaderResponse', "/variantset/#{id}", 'GET', query_params)
      end
      
      # List the variants in a set of variants. Maximum returned records is 1000.
      # 
      # +id+:: ID of the variant file.
      # +chrom+:: The chromosome of interest.
      # +start_pos+:: The start position of the sequence of interest.
      # +end_pos+:: The start position of the sequence of interest.
      # +format+:: Set to 'vcf' to get the results as lines in VCF format.
      # +qp+:: An (optional) object of type QueryParameters for custom sorting and filtering.
      def filter_variant_set(id, chrom, start_pos, end_pos, format, qp = {'SortBy' => 'Position'})
        query_pars = qp.kind_of?(Hash) ? QueryParameters.new(qp) : qp
        query_pars.validate
        query_params = query_pars.get_parameter_dict
        query_params['StartPos'] = start_pos
        query_params['EndPos'] = end_pos
        query_params['Format'] = format
        list_request('Variant', "/variantset/#{id}/variants/chr#{chrom}", 'GET', query_params)
      end
      
      # Mean coverage levels over a sequence interval. Returns an instance of CoverageResponse.
      # 
      # +id+:: Chromosome to query.
      # +chrom+:: The ID of the resource.
      # +start_pos+:: Get coverage starting at this position. Default is 1.
      # +end_pos+:: Get coverage up to and including this position. Default is start_pos + 1280.
      def get_interval_coverage(id, chrom, start_pos = nil, end_pos = nil)
        query_params = { 'StartPos' => to_path_value(start_pos), 'EndPos' => to_path_value(end_pos) }
        single_request('CoverageResponse', "/coverage/#{id}/#{chrom}", 'GET', query_params)
      end

      # Returns Metadata about coverage as a CoverageMetadata instance.
      # 
      # +id+:: ID of a BAM file.
      # +chrom+:: Chromosome to query.
      def get_coverage_meta_info(id, chrom)
        single_request('CoverageMetaResponse', "/coverage/#{id}/#{chrom}/meta", 'GET')
      end
       
      # Create an AppResult object.
      # 
      # +id+:: ID of the project in which the AppResult is to be added.
      # +name+:: The name of the AppResult.
      # +desc+:: A describtion of the AppResult.
      # +samples+:: List of samples (if any).
      # +app_session_id+:: If no app_session_id is given, the id used to initialize the BaseSpaceAPI instance will be used. If app_session_id is set equal to an empty string, a new appsession will be created.
      def create_app_result(id, name, desc, samples = [], app_session_id = nil)
        unless @app_session_id || app_session_id
          raise "This BaseSpaceAPI instance has no app_session_id set and no alternative id was supplied for method create_app_result"
        end
        
        query_params   = { 'appsessionid' => app_session_id || @app_session_id }    # default case, we use the current appsession
        post_data      = { 'Name' => name, 'Description' => desc }
        
        # add the sample references
        unless samples.empty?
          post_data['References'] = []
          samples.each do |s|
            post_data['References'] << { "Rel" => "using", "Type" => "Sample", "HrefContent" => @version + '/samples/' + s.id }
          end
        end

        # TODO: Implement status method for AppSession
        #unless get_app_session(query_params['appsessionid']).can_work_on
        #  raise 'AppSession status must be "running" to create an AppResult. Current status is: ' + session.status
        #end
            
        single_request('AppResultResponse', "/projects/#{id}/appresults", 'POST', query_params, {}, post_data)
      end
              
      # Uploads a file associated with an AppResult to BaseSpace and returns the corresponding file object.
      # 
      # +id+:: AppResult ID.
      # +local_path+:: The local path to the file to be uploaded.
      # +file_name+:: The desired filename in the AppResult folder on the BaseSpace server.
      # +directory+:: The directory the file should be placed in.
      # +content_type+:: The content-type of the file.
      def app_result_file_upload(id, local_path, file_name, directory, content_type, multipart = 0)
        query_params = { 'name' => file_name, 'directory' => directory}
        post_data = nil
        force_post = false

        # three cases, two for multipart, starting 
        case multipart
        when 1
          # Set force post as this need to use POST though no data is being streamed
          force_post = true
          query_params['multipart'] = 'true'
        when 2
          # Set force post as this need to use POST though no data is being streamed
          force_post = true
          query_params = {'uploadstatus' => 'complete'}
        else
          post_data = ::File.open(local_path).read
        end
        single_request('FileResponse', "/appresults/#{id}/files", 'POST', query_params, { 'Content-Type' => content_type }, post_data, false, force_post)
      end

      # Downloads a BaseSpace file to a local directory. Returns true on success.
      # 
      # +id+:: File ID.
      # +local_dir+:: The local directory to place the file in.
      # +name+:: The name of the local file.
      # +range+:: The byte range of the file to retrieve (not yet implemented).
      def file_download(id, local_dir, name, range = [])  #@ReservedAssignment
        response = @api_client.call_api("/files/#{id}/content", 'GET', { 'redirect' => 'meta' })

        if response['ResponseStatus'].has_key?('ErrorCode')
          raise "BaseSpace error: #{response['ResponseStatus']['ErrorCode']}: #{response['ResponseStatus']['Message']}"
        end
        
        # get the Amazon URL 
        file_url = response['Response']['HrefContent']

        unless range.empty?
          # puts "Case range request" 
          header = { 'Range' => format('bytes=%s-%s', range[0], range[1]) }
        end
        
        # Do the download
        ::File.open(::File.join(local_dir, name), "wb") do |fp|
          http_opts = {}
          uri = URI.parse(file_url)
          http_opts[:use_ssl] = true if uri.scheme == "https"
          res = Net::HTTP.start(uri.host, uri.port, http_opts) do |http|
            # [TODO] Do we need user and pass here also?
            if uri.query and not uri.query.empty?
              http.get(uri.path + '?' + uri.query, nil)
            else
              http.get(uri.path, nil)
            end
          end
          fp.print res.body
        end
        true
      end

      # Returns URL of a file on S3.
      # 
      # +id+:: File ID.
      def file_url(id)  # @ReservedAssignment
        response = @api_client.call_api("/files/#{id}/content", 'GET', { 'redirect' => 'meta' })

        if response['ResponseStatus'].has_key?('ErrorCode')
          raise "BaseSpace error: #{response['ResponseStatus']['ErrorCode']}: #{response['ResponseStatus']['Message']}"
        end
        
        # return the Amazon URL 
        response['Response']['HrefContent']
      end


      # Helper method for uploading multipart files, do not call directly.
      # 
      # +id+:: File ID.
      # +part_number+:: File part to be uploaded.
      # +md5+:: MD5 sum of datastream.
      # +data+:: The data-stream to be uploaded.
      def upload_multipart_unit(id, part_number, md5, data)
        out = @api_client.call_api("/files/#{id}/parts/#{part_number.to_s}", 'PUT', {}, data, {'Content-MD5' => md5.strip()})
        # curl -v -H "x-access-token: {access token}" \
        #   -H "Content-MD5: 9mvo6qaA+FL1sbsIn1tnTg==" \
        #   -T reportarchive.zipaa \
        #   -X PUT https://api.cloud-endor.illumina.com/v1pre2/files/7094087/parts/1
      end

      # Not yet implemented (by Illumina Python SDK)
      #
      # def large_file_download
      #   raise 'Not yet implemented'
      # end
      
      # Method for multi-threaded file-upload for parallel transfer of very large files (currently only runs on unix systems)
      # 
      # 
      # :param id: The AppResult ID
      # :param local_path: The local path of the file to be uploaded
      # :param file_name: The desired filename on the server
      # :param directory: The server directory to place the file in (empty string will place it in the root directory)
      # :param content_type: The content type of the file
      # :param tempdir: Temp directory to use, if blank the directory for 'local_path' will be used
      # :param cpuCount: The number of CPUs to be used
      # :param partSize: The size of individual upload parts (must be between 5 and 25mb)
      # :param verbose: Write process output to stdout as upload progresses
      #
      # def multipart_file_upload(self, id, local_path, file_name, directory, content_type, tempdir = nil, cpuCount = 2, partSize = 25, verbose = false)
      #   # Create file object on server
      #   multipart = 1
      #   my_file = app_result_file_upload(id, local_path, file_name, directory, content_type, multipart)
      #
      #   # prepare multi-par upload objects
      #   my_mpu = mpu(self, id, local_path, my_file, cpu_count, part_size, tempdir, verbose)
      #   return my_mpu
      # end
      #
      # def mark_file_state(id)
      # end

      # Set the status of an AppResult object.
      # 
      # +id+:: The id of the AppResult.
      # +status+:: Status assignment string.
      # +summary+:: Summary string.
      def set_app_session_state(id, status, summary)
        status_allowed = ['running', 'complete', 'needsattention', 'aborted', 'error']
        unless status_allowed.include?(status.downcase)
          raise "AppResult state must be in #{status_allowed.inspect}"
        end
        
        single_request('AppSessionResponse', "/appsessions/#{id}", 'POST', {}, {}, { 'status' => status.downcase, 'statussummary' => summary })
      end
    end
  end # module BaseSpace
end # module Bio

